#FUNC 0 loadMatrix
#FUNC % transformPoint(float, float, float) //x,y,z
#FUNC % transformDestination // input X=F1 Y=F2 Z=F3 out X'=F16 Y'=F17 Z'=18
#FUNC % transformInit
#FUNC % INVERSE_4x4 // for square 4x4  matricies MA = inv(MB)

//**********************************************
//*** FPUTransform_determineBedOrientation() ***

X1 CON 15.0
Y1 CON 15.0
Z1 EQU FLOAT

Y2 EQU FLOAT
Z2 EQU FLOAT

X3 EQU FLOAT
Z3 EQU FLOAT


newPoint EQU F16 //4x1 matrix 16 - 19

//function space F5 - F15

MasterTransform EQU F20 //4x4matrix 20 - 36

Xdiff EQU F81
Ydiff EQU F82
ZdiffX EQU F83
ZdiffY EQU F84

Xdiff = X1 - X3
Ydiff = Y1 - Y2
ZdiffX = Z1 - Z3
ZdiffY = Z1 - Z2

Z1_value EQU F12
Z1_value = Z1

loadMatrix

//********************************************
//***** FPUTransform_init()

transformInit

//********************************************
//***** FPUTransform_transformDestination()

//uses new point for return value
//newPoint EQU F16 //4x1 matrix 16 - 19
XPoint EQU FLOAT
YPoint EQU FLOAT
ZPoint EQU FLOAT

F85 = XPoint
F86 = YPoint
F87 = ZPoint
transformDestination
XPoint = F85
YPoint = F86
ZPoint = F87


//********************************************
//*** Function definitions

#FUNCTION transformInit
// It is important to ensure that if the bed levelling routine has not been called the printer 
// behaves as if the real world and idealised world are one and the same
SELECTMA(MasterTransform, 4, 4)
MOP(IDENTITY)

#FUNCTION transformDestination
transformPoint(F85, F86, F87)
SELECTMA(newPoint, 4,1 )
MOP(SAVEAR, F85, F86, F87, F88)

#FUNCTION transformPoint(float, float, float)
oldPoint EQU F69 //1x4 matrix 12 - 15
one EQU F11
one = 1
SELECTMB(oldPoint, 1, 4)
MOP(LOADRB, arg1, arg2, arg3, one)

SELECTMC(MasterTransform, 4, 4)

SELECTMA(newPoint, 4,1 )

MOP(MULTIPLY)

#FUNCTION loadMatrix


Xtheta EQU F75
Ytheta EQU F76
cosxtheta EQU f77
sinxtheta EQU f78
cosytheta EQU f79
sinytheta EQU f80
one EQU F11
one = 1.0
Transform1 EQU F37 //4x4matrix 37 - 52
Transform2 EQU F53 //4x4matrix 53 - 68


Xtheta = ZdiffX / Xdiff
Ytheta = ZdiffY / Ydiff
cosxtheta = cos(Xtheta)
sinxtheta = sin(Xtheta)
cosytheta = cos(Ytheta)
sinytheta = sin(Ytheta)

//first rotate in Y using XZ 
//[cos(t), 0, -sin(t), 0]
//[0     , 1, 0      , 0]
//[sin{t}, 0,  cos(t), 0]
//[0     , 0, 0      , 1]

SELECTMB(Transform1, 4, 4)
MOP(LOADRB, cosxtheta, F0, -sinxtheta, F0, F0, one, F0, F0, sinxtheta, F0,  cosxtheta, F0, F0, F0, F0, one)
//first rotate in X using YZ 
//[1,       0, 0     , 0]
//[0,  cos(t), sin(t), 0]
//[0, -sin{t}, cos(t), 0]
//[0,       0, 0     , 1]

SELECTMC(Transform2, 4, 4)
MOP(LOADRC, one, F0, F0, F0, F0, cosxtheta, sinxtheta, F0, F0,-sinxtheta, cosxtheta, F0, F0, F0, F0, one)
SELECTMA(MasterTransform, 4, 4)
MOP(IDENTITY)
MOP(MULTIPLY)

//now we have the object in a plane that is parallel to the x axes, but we do not have the z height correct.
//transform the x15 y15 position using our rotation matrix and use the result to determine where z0 is and
//add this translate function to the transform matrix.

SELECTMA(Transform2, 4, 4)
MOP(IDENTITY)
transformPoint(X1, Y1, Z1_value)
SELECTMA(newPoint, 4,1 )
MOP(SAVEAR, F1, F2, F3, -F0)
F65 = 15-F1     //f65 is reference into Transform2 for x translate value
F66 = 15-F2     //f66 is reference into Transform2 for y translate value
F67 = -F3     //f67 is reference into Transform2 for z translate value

SELECTMC(Transform2, 4, 4) //this is the new translate matrix

SELECTMA(MasterTransform, 4, 4)  // copy this into Transform 1
SELECTMB(Transform1, 4, 4)
MOP(COPYAB)
//now everything is in place
MOP(MULTIPLY) // MA = MB . MC

// We now have a way to translate from real-world coordinates to idealised coortdinates, but what we actually want is 
// a way to transform from the idealised g-code coordinates to real world coordinates. This is simply the inverse.
MOP(COPYAB)
//now everything is in place
INVERSE_4x4 // MA = inverse(MB)
SELECTMB(MasterTransform, 4, 4)  // copy this into Transform 1
MOP(COPYBA)

#FUNCTION INVERSE_4x4() // for square 4x4  matricies MA = inv(MB) using Gauss-Jordan elimination
//TRACEON
//BREAK
CalculaionMatrix EQU F90  // 4x8 matrix
workMatrix EQU F53 // temp 4x4 matrix or 8x1

//DestMatrix EQU U86


//DestMatrix  = READVAR(2)
SELECTMA(workMatrix, 4, 4) 
MOP(COPYBA) // copy the source data into a known location 
   //(cannot do indirect referecing of registers as if htey were memory locations so need 
   // to hardcode the registers)

SELECTMA(CalculaionMatrix, 8, 4)
MOP(SCALAR_SET, 0) // clear matrix

//spread into working matrix
SELECTMB(F90, 1, 8)
SELECTMA(F53, 1, 4)
MOP(COPYAB)
F94 = 1.0

SELECTMB(F98, 1, 8)
SELECTMA(F57, 1, 4)
MOP(COPYAB)
F103 = 1.0

SELECTMB(F106, 1, 8)
SELECTMA(F61, 1, 4)
MOP(COPYAB)
F112 = 1.0

SELECTMB(F114, 1, 8)
SELECTMA(F65, 1, 4)
MOP(COPYAB)
F121 = 1.0

//there are 16 steps, one for each cell. Cannot do htis as a loop because of hte limitations of the interpriter 
//(have to rewrite in ASM some time)

// ##1 - C1 
// #1 - R90
SELECTMA(F90, 1, 8)  // =R
MOP(SCALAR_DIV, F90) // =R+C-1

// #2 - R98
SELECTMB(F90, 1, 8)  // =#1 R
SELECTMA(F53, 1, 8) 
MOP(COPYBA)
MOP(SCALAR_MUL, F98) // = R+C-1 //multiply row 1 by the next primary element
SELECTMA(F98, 1, 8)  // = R
SELECTMB(F53, 1, 8)
MOP(EWISE_SUB)

// #3 - R106
SELECTMB(F90, 1, 8)
SELECTMA(F53, 1, 8)
MOP(COPYBA)
MOP(SCALAR_MUL, F106)  //multiply row 1 by the next primary element
SELECTMA(F106, 1, 8)
SELECTMB(F53, 1, 8)
MOP(EWISE_SUB)

// #4 - R114
SELECTMB(F90, 1, 8)
SELECTMA(F53, 1, 8)
MOP(COPYBA)
MOP(SCALAR_MUL, F114)  //multiply row 1 by the next primary element
SELECTMA(F114, 1, 8)
SELECTMB(F53, 1, 8)
MOP(EWISE_SUB)

// ##2 - C2 
// #1 - R98
SELECTMA(F98, 1, 8)
MOP(SCALAR_DIV, F99) // R+C = primary element

// #2 - R90
SELECTMB(F98, 1, 8)
SELECTMA(F53, 1, 8)
MOP(COPYBA)
MOP(SCALAR_MUL, F91)  //multiply row 1 by the next primary element
SELECTMA(F90, 1, 8)
SELECTMB(F53, 1, 8)
MOP(EWISE_SUB)

// #3 - R106
SELECTMB(F98, 1, 8)
SELECTMA(F53, 1, 8)
MOP(COPYBA)
MOP(SCALAR_MUL, F107)  //multiply row 1 by the next primary element
SELECTMA(F106, 1, 8)
SELECTMB(F53, 1, 8)
MOP(EWISE_SUB)

// #4 - R114
SELECTMB(F98, 1, 8)
SELECTMA(F53, 1, 8)
MOP(COPYBA)
MOP(SCALAR_MUL, F115)  //multiply row 1 by the next primary element
SELECTMA(F114, 1, 8)
SELECTMB(F53, 1, 8)
MOP(EWISE_SUB)

// ##3 - C3 
// #1 - R106
SELECTMA(F106, 1, 8)
MOP(SCALAR_DIV, F108) // R+C-1 = primary element

// #2 - R90
SELECTMB(F106, 1, 8)
SELECTMA(F53, 1, 8)
MOP(COPYBA)
MOP(SCALAR_MUL, F92)  //multiply row 1 by the next primary element
SELECTMA(F90, 1, 8)
SELECTMB(F53, 1, 8)
MOP(EWISE_SUB)

// #3 - R98
SELECTMB(F106, 1, 8)
SELECTMA(F53, 1, 8)
MOP(COPYBA)
MOP(SCALAR_MUL, F100)  //multiply row 1 by the next primary element
SELECTMA(F98, 1, 8)
SELECTMB(F53, 1, 8)
MOP(EWISE_SUB)

// #4 - R114
SELECTMB(F106, 1, 8)
SELECTMA(F53, 1, 8)
MOP(COPYBA)
MOP(SCALAR_MUL, F116)  //multiply row 1 by the next primary element
SELECTMA(F114, 1, 8)
SELECTMB(F53, 1, 8)
MOP(EWISE_SUB)

// ##3 - C3 
// #1 - R114
SELECTMA(F114, 1, 8)
MOP(SCALAR_DIV, F117) // R+C-1 = primary element

// #2 - R90
SELECTMB(F114, 1, 8)
SELECTMA(F53, 1, 8)
MOP(COPYBA)
MOP(SCALAR_MUL, F93)  //multiply row 1 by the next primary element
SELECTMA(F90, 1, 8)
SELECTMB(F53, 1, 8)
MOP(EWISE_SUB)

// #3 - R98
SELECTMB(F114, 1, 8)
SELECTMA(F53, 1, 8)
MOP(COPYBA)
MOP(SCALAR_MUL, F101)  //multiply row 1 by the next primary element
SELECTMA(F98, 1, 8)
SELECTMB(F53, 1, 8)
MOP(EWISE_SUB)

// #4 - R106
SELECTMB(F114, 1, 8)
SELECTMA(F53, 1, 8)
MOP(COPYBA)
MOP(SCALAR_MUL, F109)  //multiply row 1 by the next primary element
SELECTMA(F106, 1, 8)
SELECTMB(F53, 1, 8)
MOP(EWISE_SUB)

//Now extract the answer
SELECTMB(F90, 1, 8)
SELECTMA(F53, 1, 4)
MOP(COPYBA)

SELECTMB(F98, 1, 8)
SELECTMA(F57, 1, 4)
MOP(COPYBA)

SELECTMB(F106, 1, 8)
SELECTMA(F61, 1, 4)
MOP(COPYBA)

SELECTMB(F114, 1, 8)
SELECTMA(F65, 1, 4)
MOP(COPYBA)

TRACEOFF
#END
